package main

import (
	"fmt"
	"strconv"

	"github.com/aaronkaz/protobuf-go-plugins/internal/protoplugin"
	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/reflect/protoreflect"
	"google.golang.org/protobuf/reflect/protoregistry"
	"google.golang.org/protobuf/types/descriptorpb"
)

const (
	pluginName     = "protoc-gen-enum-desc-go"
	version        = "0.1.0"
	extNumber      = 200000002
	contextPackage = protogen.GoImportPath("context")
)

type getGeneratedFile func() *protogen.GeneratedFile

func main() {
	protoplugin.Run(func(p *protogen.Plugin, f *protogen.File, extTypes *protoregistry.Types) *protogen.GeneratedFile {
		// lazy create the generated file from this getter
		var generated *protogen.GeneratedFile
		g := func() *protogen.GeneratedFile {
			if generated == nil {
				filename := fmt.Sprintf("%s_enum_desc.pb.go", f.GeneratedFilenamePrefix)
				g := p.NewGeneratedFile(filename, f.GoImportPath)
				generated = g
				g.P("// Code generated by ", pluginName, ". DO NOT EDIT.")
				g.P("// versions:")
				g.P("// - ", pluginName, " v", version)
				g.P("// - protoc             ", protoplugin.ProtocVersion(p))
				if f.Proto.GetOptions().GetDeprecated() {
					g.P("// ", f.Desc.Path(), " is a deprecated file.")
				} else {
					g.P("// source: ", f.Desc.Path())
				}
				g.P()
				g.P("package ", f.GoPackageName)
				g.P()
			}

			return generated
		}

		genEnum(extTypes, g, f.Enums)
		// TODO: generate for nested enums
		// see https://github.com/protocolbuffers/protobuf-go/blob/55f120eb3b91659cee86adeed925c825686556b0/cmd/protoc-gen-go/internal_gengo/init.go#L50

		return generated
	})
}

func genEnum(extTypes *protoregistry.Types, g getGeneratedFile, enums []*protogen.Enum) error {
	if len(enums) == 0 {
		return nil
	}

	for _, e := range enums {
		// another getter to lazy start enum declaration
		var enumGenerated bool
		eg := func() *protogen.GeneratedFile {
			if !enumGenerated {
				g().P("// Enum description value maps for ", e.GoIdent, ".")
				g().P("var "+e.GoIdent.GoName+"_desc", " = map[int32]string{")
				enumGenerated = true
			}

			return g()
		}
		for _, ev := range e.Values {
			if ev.Desc.Options() == nil || ev.Desc.Options().(*descriptorpb.EnumValueOptions) == nil {
				continue
			}
			opts, err := protoplugin.OptionsReflect(extTypes, ev.Desc.Options().(*descriptorpb.EnumValueOptions))
			if err != nil {
				return err
			}
			if !protoplugin.IsExtension(opts, extNumber) {
				continue
			}

			var val string

			opts.Range(func(fd protoreflect.FieldDescriptor, v protoreflect.Value) bool {
				val = v.String()
				return true
			})

			eg().P(ev.Desc.Number(), ": ", strconv.Quote(val), ",")
		}
		if enumGenerated {
			g().P("}")
			g().P()

			g().P("func (x " + e.GoIdent.GoName + ") Desc() string {")
			g().P("if v, ok := " + e.GoIdent.GoName + "_desc[int32(x)]; ok {")
			g().P("return v")
			g().P("}")
			g().P("return " + strconv.Quote(""))
			g().P("}")
			g().P()

		}
	}

	return nil
}
