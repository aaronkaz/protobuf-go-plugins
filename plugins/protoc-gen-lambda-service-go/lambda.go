package main

import (
	"errors"
	"fmt"

	"github.com/aaronkaz/protobuf-go-plugins/internal/protoplugin"
	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/reflect/protoregistry"
	"google.golang.org/protobuf/types/descriptorpb"
)

const (
	contextPackage = protogen.GoImportPath("context")
	lambdaPackage  = protogen.GoImportPath("github.com/aws/aws-lambda-go/lambda")
)

type lambdaProtoService struct {
	proto   *protogen.Service
	isProxy bool
}

func getLambdaProtoServices(extTypes *protoregistry.Types, f *protogen.File) ([]*lambdaProtoService, error) {
	svs := make([]*lambdaProtoService, 0)
	for _, s := range f.Services {
		if s.Desc.Options() == nil || s.Desc.Options().(*descriptorpb.ServiceOptions) == nil {
			continue
		}

		opts, err := protoplugin.OptionsReflect(extTypes, s.Desc.Options().(*descriptorpb.ServiceOptions))
		if err != nil {
			return svs, err
		}
		if !protoplugin.IsExtension(opts, extNumber) {
			continue
		}

		isProxy, err := protoplugin.GetProtoReflectFieldValue(opts, "is_proxy")
		if err != nil {
			return svs, err
		}

		// validate that a non-proxy lambda can only have one method
		if !isProxy.Bool() && len(s.Methods) != 1 {
			return svs, errors.New("Lambda services not of proxy type must declare exactly 1 method!")
		}

		svs = append(svs, &lambdaProtoService{
			proto:   s,
			isProxy: isProxy.Bool(),
		})
	}

	return svs, nil
}

func generateFile(gen *protogen.Plugin, file *protogen.File, svs []*lambdaProtoService) *protogen.GeneratedFile {
	if len(svs) == 0 {
		return nil
	}

	filename := fmt.Sprintf("%s_lambda.pb.go", file.GeneratedFilenamePrefix)
	g := gen.NewGeneratedFile(filename, file.GoImportPath)

	g.P("// Code generated by ", pluginName, ". DO NOT EDIT.")
	g.P("// versions:")
	g.P("// - ", pluginName, " v", version)
	g.P("// - protoc             ", protoplugin.ProtocVersion(gen))
	if file.Proto.GetOptions().GetDeprecated() {
		g.P("// ", file.Desc.Path(), " is a deprecated file.")
	} else {
		g.P("// source: ", file.Desc.Path())
	}
	g.P()
	g.P("package ", file.GoPackageName)
	g.P()

	for _, sv := range svs {
		generateLambdaFileContent(g, sv)
	}

	return g
}

func generateLambdaFileContent(g *protogen.GeneratedFile, fn *lambdaProtoService) {
	if !fn.isProxy {
		service := fn.proto
		handlerMethod := service.Methods[0]
		serviceFn := fmt.Sprintf("Start%sLambda", service.Desc.Name())
		g.P("func ", serviceFn, "(svc interface {")
		g.P(handlerMethod.Desc.Name(), lambdaMethodSignature(g, handlerMethod))
		g.P("}) {")
		g.P(lambdaPackage.Ident("Start"), "(svc.", handlerMethod.Desc.Name(), ")")
		g.P("}")
		g.P()

		handlerFn := fmt.Sprintf("Start%s%sLambdaHandler", service.Desc.Name(), handlerMethod.Desc.Name())
		g.P("func ", handlerFn, "(handler func", lambdaMethodSignature(g, handlerMethod), ") {")
		g.P(lambdaPackage.Ident("Start"), "(handler)")
		g.P("}")
		g.P()
	}

}

func lambdaMethodSignature(g *protogen.GeneratedFile, method *protogen.Method) string {
	// using `QualifiedGoIdent` does magic to insert any imports outside the current package
	s := "(ctx " + g.QualifiedGoIdent(contextPackage.Ident("Context"))
	s += ", in *" + g.QualifiedGoIdent(method.Input.GoIdent) + ") ("
	s += "*" + g.QualifiedGoIdent(method.Output.GoIdent)
	s += ", error)"

	return s
}
