package main

import (
	"fmt"

	"github.com/aaronkaz/protobuf-go-plugins/internal/protoplugin"
	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/reflect/protoregistry"
	"google.golang.org/protobuf/types/descriptorpb"
)

const (
	contextPackage = protogen.GoImportPath("context")
)

func generateFile(gen *protogen.Plugin, file *protogen.File, mtds []*protogen.Method) *protogen.GeneratedFile {
	if len(mtds) == 0 {
		return nil
	}

	filename := fmt.Sprintf("%s_func.pb.go", file.GeneratedFilenamePrefix)
	g := gen.NewGeneratedFile(filename, file.GoImportPath)

	g.P("// Code generated by ", pluginName, ". DO NOT EDIT.")
	g.P("// versions:")
	g.P("// - ", pluginName, " v", version)
	g.P("// - protoc             ", protoplugin.ProtocVersion(gen))
	if file.Proto.GetOptions().GetDeprecated() {
		g.P("// ", file.Desc.Path(), " is a deprecated file.")
	} else {
		g.P("// source: ", file.Desc.Path())
	}
	g.P()
	g.P("package ", file.GoPackageName)
	g.P()

	for _, mtd := range mtds {
		genMethod(g, mtd)
	}

	return g
}

func getAbstractMethods(extTypes *protoregistry.Types, file *protogen.File) ([]*protogen.Method, error) {
	mtds := make([]*protogen.Method, 0)
	for _, s := range file.Services {
		for _, m := range s.Methods {
			if m.Desc.Options() == nil || m.Desc.Options().(*descriptorpb.MethodOptions) == nil {
				continue
			}

			opts, err := protoplugin.OptionsReflect(extTypes, m.Desc.Options().(*descriptorpb.MethodOptions))
			if err != nil {
				return mtds, err
			}
			if !protoplugin.IsExtension(opts, extNumber) {
				continue
			}

			mtds = append(mtds, m)
		}
	}

	return mtds, nil
}

func genMethod(g *protogen.GeneratedFile, method *protogen.Method) {
	// generate interface
	g.P("type Can", method.Desc.Name(), " interface {")
	g.P(method.Desc.Name(), methodSignature(g, method))
	g.P("}")
	g.P()

	// generate function type
	g.P("type ", method.Desc.Name(), "Func func", methodSignature(g, method))
	g.P()
}

func methodSignature(g *protogen.GeneratedFile, method *protogen.Method) string {
	// using `QualifiedGoIdent` does magic to insert any imports outside the current package
	s := "(ctx " + g.QualifiedGoIdent(contextPackage.Ident("Context"))
	s += ", in *" + g.QualifiedGoIdent(method.Input.GoIdent) + ") ("
	s += "*" + g.QualifiedGoIdent(method.Output.GoIdent)
	s += ", error)"

	return s
}
